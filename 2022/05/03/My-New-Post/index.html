<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1"><meta name="robots" content="index, follow"><title>CSAPP 读书笔记 • Hexo</title><meta name="description" content="CSAPP 读书笔记 - John Doe"><link rel="icon" href="/favicon.svg"><link rel="stylesheet" href="https://unpkg.com/nanoreset@3.0.1/nanoreset.min.css"><link rel="stylesheet" href="/css/theme.css"><link rel="search" type="application/opensearchdescription+xml" href="/atom.xml" title="Hexo"><script type="text/javascript" id="maid-script" src="https://unpkg.com/mermaid@9.0.1/dist/mermaid.min.js?v=undefined"></script><script>if (window.mermaid) {
  var options = JSON.parse(document.getElementById('maid-script').getAttribute('mermaidoptioins'));
  mermaid.initialize(options);
}</script><meta name="generator" content="Hexo 6.1.0"><link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
</head><body><div class="wrap" id="barba-wrapper"><header><h1 class="branding"><a href="/" title="Hexo">Hexo</a></h1><ul class="nav nav-list"><li class="nav-list-item"><a class="nav-list-link no-barba" href="/" target="_self">HOME</a></li><li class="nav-list-item"><a class="nav-list-link no-barba" href="/about" target="_self">ABOUT</a></li><li class="nav-list-item"><a class="nav-list-link no-barba" href="/archives" target="_self">ARCHIVES</a></li><li class="nav-list-item"></ul></header><div class="barba-container"><main class="container"><div class="post"><article class="post-block"><h1 class="post-title">CSAPP 读书笔记</h1><div class="post-info"><a></a>2022-05-03</div><div class="post-content"><h1 id="第-1-章-计算机系统漫游"><a href="#第-1-章-计算机系统漫游" class="headerlink" title="第 1 章 计算机系统漫游"></a>第 1 章 计算机系统漫游</h1><h2 id="1-2-程序被其他程序翻译成不同格式"><a href="#1-2-程序被其他程序翻译成不同格式" class="headerlink" title="1.2 程序被其他程序翻译成不同格式"></a>1.2 程序被其他程序翻译成不同格式</h2><pre class="mermaid">graph LR;
  A(预处理器<br>cpp) --hell.i<br>修改了的源程序--> B
  B(编译器<br>cll) --hell.s<br>汇编程序--> C
  X(printf.o) --> D
  C(汇编器<br>as) --hell.o<br>可重定位目标程序--> D(链接器<br>ld)
  D --> F(hello<br>可执行目标程序)
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&lt;br&gt;</span><br><span class="line"></span><br><span class="line">### 1.4.1 系统的硬件组成  </span><br><span class="line">内存是由一组动态随机存储器（DRAM）芯片组成的  </span><br><span class="line"></span><br><span class="line">L1 和 L2 高速缓存是用静态随机访问存储器（SRAM）的硬件技术实现的  </span><br><span class="line">&lt;br&gt;</span><br><span class="line"></span><br><span class="line">## 1.7 操作系统管理硬件</span><br><span class="line"></span><br><span class="line">```mermaid</span><br><span class="line">flowchart LR</span><br><span class="line">    A(操作系统&lt;br&gt;有两个基本功能) --&gt; B(1 防止硬件被失控的程序滥用)</span><br><span class="line">    A --&gt; C(2 向应用程序提供简单一致的机制&lt;br&gt;来控制复杂而又大不相同的低级硬件设备)&lt;/pre&gt;</span><br><span class="line"></span><br><span class="line">操作系统通过 3 个抽象概念（进程、虚拟内存和文件）来实现这两个功能：</span><br><span class="line">1、文件是对 I/O 设备的抽象表示</span><br><span class="line">2、虚拟内存是对内存和磁盘 I/O 设备的抽象表示</span><br><span class="line">3、进程是对处理器、内存和 I/O 设备的抽象表示  </span><br><span class="line"></span><br><span class="line">虚拟机是对整个计算机对抽象，包括操作系统、处理器和程序</span><br><span class="line">&lt;br&gt;</span><br><span class="line"></span><br><span class="line">### 1.7.1 进程</span><br><span class="line">&lt;font color=red&gt;进程是操作系统对一个正在运行的程序的一种抽象&lt;/font&gt;  </span><br><span class="line"></span><br><span class="line">并发运行，则是说一个进程的指令和另一个进程的指令是交错执行的</span><br><span class="line"></span><br><span class="line">OS 保持跟进进程运行所需的所有状态信息（上下文），比如 PC 和寄存器文件的当前值，以及内存的内容</span><br><span class="line"></span><br><span class="line">进程间的切换是由操作系统内核（kernel）管理的，内核是操作系统代码常驻内存的部分</span><br><span class="line"></span><br><span class="line">当应用程序需要 OS 的某些操作时（比如读写文件），它就执行一条特殊的系统调用（systemp call）指令，&lt;br&gt;将控制权传递给内核，然后内核执行被请求的操作并返回应用程序  </span><br><span class="line">&lt;br&gt;</span><br><span class="line"></span><br><span class="line">### 1.7.2 线程</span><br><span class="line">一个进程实际上可以由&lt;font color=red&gt;多个线程&lt;/font&gt;的执行单元组成，每个线程都运行在进程的上下文中，并共享同样的代码和全局数据</span><br><span class="line">&lt;br&gt;</span><br><span class="line"></span><br><span class="line">### 1.7.3 虚拟内存</span><br><span class="line">虚拟内存是一个抽象概念，它为每个进程提供了一个假象，即每个进程都在独占地使用内存  </span><br><span class="line"></span><br><span class="line">每个进程看到的内存都是一致的，称为`虚拟地址空间`</span><br><span class="line"></span><br><span class="line">进程的虚拟地址空间图（从下往上，地址增大）：</span><br><span class="line">&lt;pre class=&quot;mermaid&quot;&gt;graph TB;</span><br><span class="line">    A(内核虚拟内存) --&gt; B(用户栈&lt;br&gt;运行时创建)</span><br><span class="line">    B --&gt; C(null)</span><br><span class="line">    C --&gt; D(共享库的内存&lt;br&gt;映射区域)</span><br><span class="line">    D --&gt; E(null)</span><br><span class="line">    E --&gt; F(运行时堆&lt;br&gt;在运行时由 malloc 创建)</span><br><span class="line">    F --&gt; G(读/写数据)</span><br><span class="line">    G --&gt; H(只读的代码和数据)&lt;/pre&gt;</span><br><span class="line"></span><br><span class="line">&lt;br&gt;</span><br><span class="line"></span><br><span class="line">### 1.7.4 文件</span><br><span class="line">&lt;font color=red&gt;文件就是字节序列&lt;/font&gt;</span><br><span class="line"></span><br><span class="line">系统中的`所有输入输出`都是通过使用一小组称为 Unix I/O 的系统函数调用读写文件来实现的</span><br><span class="line">&lt;br&gt;</span><br><span class="line"></span><br><span class="line">### 1.9.2 并发和并行</span><br><span class="line">并发（concurrency）指一个同时具有多个活动多系统</span><br><span class="line">并行（parallelism）指的是用并发来使一个系统运行得更快</span><br><span class="line"></span><br><span class="line">#### 1、线程级并发</span><br><span class="line">多核处理器是将多个CPU（称为“核”）集成到一个集成电路芯片上，每个核都有自己的 L1 和 L2 高速缓存</span><br><span class="line"></span><br><span class="line">超线程，有时称为同时多线程（simultaneous multi-threading），是一项允许一个 CPU 执行多个控制流的技术。举例子来说，Intel Core i7 处理器可以让每个核执行两个线程，所以一个 4 核的系统实际上可以并行地执行 8 个线程</span><br><span class="line"></span><br><span class="line">#### 2、指令级并行</span><br><span class="line">在较低的抽象层次上，现代处理器可以同时执行多条指令的属性称为指令级并行</span><br><span class="line"></span><br><span class="line">如果处理器可以达到比一个周期一条指令更快的执行效率，就称之为`超标量`（super-scalar）处理器</span><br><span class="line"></span><br><span class="line">#### 3、单指令、多数据并行</span><br><span class="line">在最低层次上，许多现代处理器拥有特殊的硬件，允许一条指令产生多个可以并行的操作，这种方式称为单指令、多数据，即 SIMD 并行  </span><br><span class="line">&lt;br&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 第 2 章 程序结构和执行</span><br><span class="line">## 2.1 信息存储</span><br><span class="line">机器级程序将内存视为一个非常大的字节数组，称为虚拟内存（virtual memory）。内存的每个字节都由一个唯一的数字来标识，称为它的地址，所有可能地址的集合称为虚拟地址空间（virtual address space）</span><br><span class="line"></span><br><span class="line">C 语言中一个指针的值（无论它指向一个整数、一个结构体或是某个其他程序对象）都是某个存储块的第一个字节的虚拟地址</span><br><span class="line">&lt;br&gt;</span><br><span class="line"></span><br><span class="line">### 2.1.2 字数据大小</span><br><span class="line">字长是CPU的主要技术指标之一，指的是CPU一次能并行处理的二进制位数，字长总是8的整数倍 </span><br><span class="line"></span><br><span class="line">字长决定的最重要的系统参数就是虚拟地址空间的大小，对于一个字长为 w 位的机器而言，虚拟地址的范围为 0～2^w^-1 </span><br><span class="line"></span><br><span class="line">比如 32 位字长限制虚拟地址空间位 4 千兆字节（4GB），2^32^ = 2^10^(k) * 2^10^(M) * 2^10^(G) * 4  </span><br><span class="line"></span><br></pre></td></tr></table></figure>
linux> gcc -m32 prog.c # 可以在 32 位或 64 位机器上运行
linux> gcc -m64 prog.c # 只能在 64 位机器上运行
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line">因此我们将程序称为 “32 位程序” 或 “64 位程序”时，区别在于该程序是`如何编译`的，而不是其运行的机器类型</span><br><span class="line"></span><br><span class="line">### 2.1.4 表示字符串</span><br><span class="line">不同的机器使用不同的且不兼容的指令和编码方式。即使是完全一样的进程，运行在不同的操作系统上也会有不同的编码规则，因此二进制代码是不兼容的。二进制代码很少能在不同机器和操作系统组合之间移植</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">### 2.1.6 布尔代数简介</span><br><span class="line">|   布尔代数   |   非   |    且    |   或   |     异或     |</span><br><span class="line">| :----------: | :----: | :------: | :----: | :----------: |</span><br><span class="line">|    运算符    |   ~    |    &amp;     |   \|   |      ^       |</span><br><span class="line">|     英文     |  NOT   |   AND    |   OR   | EXCLUSIVE-OR |</span><br><span class="line">| 命题逻辑符号 | $\neg$ | $\wedge$ | $\vee$ |   $\oplus$   |</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">### 2.1.9 C 语言中的移位运算</span><br><span class="line">一般而言，机器支持两种形势的右移：</span><br><span class="line">1、逻辑右移：在左端补 k 个 0</span><br><span class="line">2、算数右移：在左端补 k 个最高有效位的值</span><br><span class="line">这种做法看上去可能有点奇特，但是发现它对有符号整数数据的运算非常有用</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">### 2.2.1 整数数据类型</span><br><span class="line">C 和 C++ 都支持有符号（默认）和无符号数。Java 只支持有符号数</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">### 2.2.2 无符号数的编码</span><br><span class="line">假设有一个整数数据类型有 $w$  位，则可以将位向量写成  $\vec&#123;x&#125;$ ，表示整个向量，或者写成 $[x_&#123;w-1&#125;,\ x_&#123;w-2&#125;,\ \cdots,\ x_0]$。在这个编码中，每个位  $x_i$  都取 0 或 1。我们用一个函数 $B2U_w$ (Binary to Unsigned 的缩写，长度为 $w$) 来表示：</span><br><span class="line">原理： 无符号数编码的定义</span><br><span class="line">对向量 $\vec&#123;x&#125;=[x_&#123;w-1&#125;,\ x_&#123;w-2&#125;,\ \cdots,\ x_0]$:</span><br><span class="line">$$B2U_w\doteq\sum\limits_&#123;i=0&#125;^&#123;w-1&#125;x_i2^i$$</span><br><span class="line">（符号 “$\doteq$” 表示左边被定义为等于右边）</span><br><span class="line"></span><br><span class="line">最小值用位向量 $[000\cdots0]$ 表示，也就是整数 0；最大值用位向量 $[111\cdots1]$ 表示，也就是整数值 $UMax_w\doteq \sum\limits_&#123;i=0&#125;^&#123;w-1&#125;2^w-1$</span><br><span class="line"></span><br><span class="line">原理：无符号数编码的唯一性</span><br><span class="line">函数 $B2U_w$ 是一个`双射`。</span><br><span class="line">数学术语双射是指一个函数 $f$  有两面：它将数值 $x$ 映射为数值 $y$，即 $y=f(x)$。但它也可以反向操作，因为对每一个 $y$ 而言，都有&lt;font color=red&gt;唯一&lt;/font&gt;一个数值 $x$ 使得 $f(x)=y$。这可以用反射函数 $f^&#123;-1&#125;$ 来表示。</span><br><span class="line">函数 $B2U_w$ 将每一个长度为 $w$ 的位向量都映射为 $0\sim2^&#123;w&#125;-1$ 之间的一个&lt;font color=red&gt;唯一&lt;/font&gt;值；</span><br><span class="line">反过来，我们称其为 $U2B_w$（即”无符号数到二进制“），在 $0\sim2^w-1$ 之间的每一个整数都可以映射为一个&lt;font color=red&gt;唯一&lt;/fond&gt;的长度为 $w$ 的位模式。</span><br><span class="line"></span><br><span class="line">### 2.2.3 补码编码</span><br><span class="line">最常见的有符号数的计算机表示方式就是`补码` (tow&#x27;s-comnplement) 形式</span><br><span class="line"></span><br><span class="line">这个形式中，将字的最高有效位表示为负权，用函数 $B2T_w$(Binary to Two&#x27;s-complement 的缩写，长度为 $w$) 来表示：</span><br><span class="line">原理：补码编码的定义</span><br><span class="line">对向量 $\vec&#123;x&#125;=[x_&#123;w-1&#125;,\ x_&#123;w-2&#125;,\ \cdots,\ x_0]$:</span><br><span class="line">$$B2T_w \doteq -x_&#123;w-1&#125;2^&#123;w-1&#125; + \sum\limits_&#123;i=0&#125;^&#123;w-2&#125;x_i2^i$$</span><br><span class="line">最高有效位 $x_&#123;w-1&#125;$ 也称为符号位，它的 “权重” 为 $2^&#123;w-1&#125;$。符号位为 1 时，表示值为负，反之为`非负`(0 不是整数也不是负数)</span><br><span class="line">$$TMin_w \doteq -2^&#123;w-1&#125;$$</span><br><span class="line">$$\begin&#123;aligned&#125; </span><br><span class="line">	TMax_w &amp;\doteq\sum\limits_&#123;i=0&#125;^&#123;w-2&#125;2^i \\</span><br><span class="line">	&amp;\doteq \frac&#123;2^0(1-2^&#123;w-2&#125;)&#125;&#123;1-2&#125; \\</span><br><span class="line">	&amp;\doteq 2^&#123;w-1&#125;-1</span><br><span class="line">\end&#123;aligned&#125;$$ </span><br><span class="line">补码的范围是不对成的：$|TMin|=|Tmax|+1$</span><br><span class="line"></span><br><span class="line">为什么？因为 0 是非负数，导致偏移量少一个单位，意味着能表示的整数比负数少一个</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">### 2.2.4 有符号数和无符号数之间的转换</span><br><span class="line">```c</span><br><span class="line">	short int v = -12345;</span><br><span class="line">	unsigned short uv = (unsigned short) v;</span><br><span class="line">	printf(&quot;v = %d, uv = %u\n&quot;, v, uv);</span><br></pre></td></tr></table></figure>
上面这段代码输出：v = -12345, uv = 53191
强制类型转换的结果保持位值不变，只是改变了解释这些位的方式




</div></article></div></main><footer><div class="paginator"><a class="next" href="/2022/05/03/hello-world/">next</a></div><div class="copyright"><p>&copy; 2022 <a target="_blank" rel="noopener" href="https://www.example.org/john-doe">Rory</a><br>Powered by <a href="https://hexo.io/" rel="noreferrer" target="_blank">Hexo</a></p></div></footer></div></div><script>var _gaq = _gaq || [];
_gaq.push(['_setAccount', 'UA-XXXXXXXX-X']);
_gaq.push(['_trackPageview']);

(function () {
    var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
    ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
})();</script><script src="https://cdnjs.cloudflare.com/ajax/libs/barba.js/1.0.0/barba.min.js"></script><script>document.addEventListener('DOMContentLoaded', function() {
    Barba.Pjax.start()
})</script></body></html>