<!DOCTYPE html><html lang="zh"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1"><meta name="robots" content="index, follow"><title>Gorm 实现自定义类型及实现 interface 的注意事项 • 保持好奇心</title><meta name="description" content="Gorm 实现自定义类型及实现 interface 的注意事项 - roryye"><link rel="icon" href="/favicon.svg"><link rel="stylesheet" href="https://unpkg.com/nanoreset@3.0.1/nanoreset.min.css"><link rel="stylesheet" href="/css/theme.css"><link rel="search" type="application/opensearchdescription+xml" href="/atom.xml" title="保持好奇心"><link href="https://lf9-cdn-tos.bytecdntp.com/cdn/expire-1-M/KaTeX/0.10.2/katex.min.css" rel="stylesheet"><script type="text/javascript" id="maid-script" src="https://unpkg.com/mermaid@9.0.1/dist/mermaid.min.js?v=undefined"></script><script>if (window.mermaid) {
  var options = JSON.parse(document.getElementById('maid-script').getAttribute('mermaidoptioins'));
  mermaid.initialize(options);
}</script><meta name="generator" content="Hexo 6.1.0"><link rel="alternate" href="/atom.xml" title="保持好奇心" type="application/atom+xml">
</head><body><div class="wrap" id="barba-wrapper"><header><h1 class="branding"><a href="/" title="保持好奇心"><img class="logo-image" src="/logo.png" alt="logo"></a></h1><ul class="nav nav-list"><li class="nav-list-item"><a class="nav-list-link no-barba" href="/" target="_self">HOME</a></li><li class="nav-list-item"><a class="nav-list-link no-barba" href="/about" target="_self">ABOUT</a></li><li class="nav-list-item"><a class="nav-list-link no-barba" href="/archives" target="_self">ARCHIVES</a></li><li class="nav-list-item"><a class="nav-list-link no-barba" href="https://github.com/roryye" target="_blank">GITHUB</a></li><li class="nav-list-item"><a class="nav-list-link no-barba" href="/atom.xml" target="_self">RSS</a></li></ul></header><div class="barba-container"><main class="container"><div class="post"><article class="post-block"><h1 class="post-title">Gorm 实现自定义类型及实现 interface 的注意事项</h1><div class="post-info"><a></a>2022-07-10</div><div class="post-content"><p>在业务开发时，偶尔有一个字段需存入 []string 信息的需求，当然，我们可以将这种复合数据进行手动的 json.Marshal 和 json.Unmarshal。但如果有多个字段需要处理，会多出很多冗余代码，而且每次存取时都需要处理，实在是不够优雅。从 gorm 官方文档<sup id="fnref:1"><a href="#fn:1" rel="footnote">1</a></sup>中查找到实现自定义数据类型的存取只需要实现 Scan 和 Value 接口即可。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> JSON json.RawMessage</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实现 sql.Scanner 接口，Scan 将 value 扫描至 Jsonb</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(j *JSON)</span></span> Scan(value <span class="keyword">interface</span>&#123;&#125;) <span class="type">error</span> &#123;</span><br><span class="line">  bytes, ok := value.([]<span class="type">byte</span>)</span><br><span class="line">  <span class="keyword">if</span> !ok &#123;</span><br><span class="line">    <span class="keyword">return</span> errors.New(fmt.Sprint(<span class="string">&quot;Failed to unmarshal JSONB value:&quot;</span>, value))</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  result := json.RawMessage&#123;&#125;</span><br><span class="line">  err := json.Unmarshal(bytes, &amp;result)</span><br><span class="line">  *j = JSON(result)</span><br><span class="line">  <span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实现 driver.Valuer 接口，Value 返回 json value</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(j JSON)</span></span> Value() (driver.Value, <span class="type">error</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> <span class="built_in">len</span>(j) == <span class="number">0</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">nil</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> json.RawMessage(j).MarshalJSON()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>下面做了下实验，为了将 People.AddressList 存入到表的 address_list 字段。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> People <span class="keyword">struct</span> &#123;</span><br><span class="line">	gorm.Model</span><br><span class="line"></span><br><span class="line">	Name        <span class="type">string</span></span><br><span class="line">	Age         <span class="type">int</span></span><br><span class="line">	AddressList AddressList</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> AddressList []*Address</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Address <span class="keyword">struct</span> &#123;</span><br><span class="line">	Country  <span class="type">string</span></span><br><span class="line">	Province <span class="type">string</span></span><br><span class="line">	City     <span class="type">string</span></span><br><span class="line">	Detail   <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(a *AddressList)</span></span> Scan(value <span class="keyword">interface</span>&#123;&#125;) <span class="type">error</span> &#123;</span><br><span class="line">	<span class="keyword">if</span> value == <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">	&#125;</span><br><span class="line">	data, ok := value.([]<span class="type">byte</span>)</span><br><span class="line">	<span class="keyword">if</span> !ok &#123;</span><br><span class="line">		<span class="keyword">return</span> fmt.Errorf(<span class="string">&quot;value is not []byte, value: %v&quot;</span>, value)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> json.Unmarshal(data, &amp;a)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(a AddressList)</span></span> Value() (driver.Value, <span class="type">error</span>) &#123;</span><br><span class="line">	<span class="keyword">return</span> json.Marshal(a)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>尝试了简单的存储操作是可以成功的，但是有个小疑问，为什么实现 Scan 接口时 AddressList 类型带了 * 号，而 Value 并没有带。为了解开心中的疑惑，我把 Value 也加上了 * 号。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(a *AddressList)</span></span> Value() (driver.Value, <span class="type">error</span>) &#123;</span><br><span class="line">	<span class="keyword">return</span> json.Marshal(a)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>加上了之后出现了下面的错误：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">sql</span>: converting argument $<span class="number">6</span> type: unsupported type main.Address, a struct</span><br><span class="line">[<span class="number">83.641</span>ms] [<span class="keyword">rows</span>:<span class="number">0</span>] <span class="keyword">INSERT</span> <span class="keyword">INTO</span> `people` (`created_at`,`updated_at`,`deleted_at`,`name`,`age`,`address_list`) <span class="keyword">VALUES</span> (<span class="string">&#x27;2022-07-10 16:08:28.617&#x27;</span>,<span class="string">&#x27;2022-07-10 16:08:28.617&#x27;</span>,<span class="keyword">NULL</span>,<span class="string">&#x27;rory&#x27;</span>,<span class="number">24</span>,(<span class="string">&#x27;&#123;China Guangdong Guangzhou xxx&#125;&#x27;</span>))</span><br><span class="line"><span class="keyword">sql</span>: converting argument $<span class="number">6</span> type: unsupported type main.Address, a struct</span><br></pre></td></tr></table></figure>
<p>可以看到 Address 并没有转换成功，也就是 AddressList 并没有实现 Value 接口。下面将问题简化一下：有一个 Animal 的接口且有一个 Eat 的方法。</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Animal <span class="keyword">interface</span> &#123;</span><br><span class="line">	Eat(food <span class="type">string</span>) <span class="type">error</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(a *AddressList)</span></span> Eat(food <span class="type">string</span>) <span class="type">error</span> &#123;</span><br><span class="line">	<span class="keyword">if</span> food != <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> errors.New(<span class="string">&quot;food is empty&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>新建测试文件：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;testing&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestInterface</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">	p := &amp;People&#123;</span><br><span class="line">		AddressList: AddressList&#123;</span><br><span class="line">			&#123;</span><br><span class="line">				Country: <span class="string">&quot;China&quot;</span>,</span><br><span class="line">			&#125;,</span><br><span class="line">		&#125;,</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">var</span> ip <span class="keyword">interface</span>&#123;&#125; = p.AddressList</span><br><span class="line">	_, ok := ip.(Animal)</span><br><span class="line">	fmt.Println(ok)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行上面的单测代码，可以看到输出的是 false，也就是说，T 类型并没有 *T 的方法（所以上面实现 Valuer 接口会报错）。改下 Eat 的 Receiver 类型：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(a AddressList)</span></span> Eat(food <span class="type">string</span>) <span class="type">error</span> &#123;</span><br><span class="line">	<span class="keyword">if</span> food != <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> errors.New(<span class="string">&quot;food is empty&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> ip <span class="keyword">interface</span>&#123;&#125; = &amp;p.AddressList</span><br></pre></td></tr></table></figure>
<p>继续执行上面的单测之后，发现输出 true，说明 *T 具有 T 类型的方法。<a target="_blank" rel="noopener" href="https://go.dev/doc/faq#Functions_methods">Go FAQ - Why do T and *T have different method sets?</a><sup id="fnref:2"><a href="#fn:2" rel="footnote">2</a></sup> 中解释了为什么这两种情况有不同的方法集:</p>
<blockquote>
<p>But if an interface value contains a value T, there is no safe way for a method call to obtain a pointer. (Doing so would allow a method to modify the contents of the value inside the interface, which is not permitted by the language specification.)</p>
</blockquote>
<p>这个限制是为了避免非预期的结果，当我们把一个方法的 Receiver 定义为指针，就期望对其内部状态的更改可带回给调用方。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> buf bytes.Buffer</span><br><span class="line">io.Copy(buf, os.Stdin) <span class="comment">// 实际上不允许，假设可以</span></span><br></pre></td></tr></table></figure>
<p>Buffer 实现了 io.Writer，假设编译器接受了这个写法，那么 Copy() 拿到的 dst io.Writer 内部包装的是 buf 的一个拷贝，Buffer.Write() 的接收器也只能拿到这个拷贝的地址。尽管理论上跑得通，但如此一来，外面的 buf 内容不会改变，显然，这和我们预期的不一样。</p>
<p>回到最开始的问题，src/database/sql/sql.go 里定义的 Scanner 接口是将数据库的数据赋值到指定类型数据中，src/database/sql/driver/types.go 中的 Valuer 接口则是将指定类型数据转换为数据库中的数据。因为想要将转换数据库的数据带回给调用方，所以实现 Scanner 接口是 *T 类型；而将指定类型的数据转换到数据库并不需要 *T，但是如果定义的指定类型数据是 T 类型而实现 Valeur 接口是 *T 类型，那么会报错并未实现 Valuer 接口。</p>
<p><sup id="fnref:1"><a href="#fn:1" rel="footnote">1</a></sup> <a target="_blank" rel="noopener" href="https://gorm.io/docs/data_types.html">https://gorm.io/docs/data_types.html</a><br />
<sup id="fnref:2"><a href="#fn:2" rel="footnote">2</a></sup> <a target="_blank" rel="noopener" href="https://go.dev/doc/faq#Functions_methods">https://go.dev/doc/faq#Functions_methods</a></p>
</div></article></div></main><footer><div class="paginator"><a class="next" href="/csapp-note/">next</a></div><div class="copyright"><p>保持好奇心 &copy; 2022 <a href="https://beian.miit.gov.cnt" rel="noreferrer" target="_blank">京ICP备2022015182号-1</a></p></div></footer></div></div><script>var _gaq = _gaq || [];
_gaq.push(['_setAccount', 'UA-XXXXXXXX-X']);
_gaq.push(['_trackPageview']);

(function () {
    var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
    ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
})();</script><script src="https://cdnjs.cloudflare.com/ajax/libs/barba.js/1.0.0/barba.min.js"></script><script>document.addEventListener('DOMContentLoaded', function() {
    Barba.Pjax.start()
})</script></body></html>