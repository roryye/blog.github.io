<!DOCTYPE html><html lang="zh"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1"><meta name="robots" content="index, follow"><title>golang 函数传递 slice 常见的坑 • 保持好奇心</title><meta name="description" content="golang 函数传递 slice 常见的坑 - roryye"><link rel="icon" href="/favicon.svg"><link rel="stylesheet" href="https://unpkg.com/nanoreset@3.0.1/nanoreset.min.css"><link rel="stylesheet" href="/css/theme.css"><link rel="search" type="application/opensearchdescription+xml" href="/atom.xml" title="保持好奇心"><link href="https://lf9-cdn-tos.bytecdntp.com/cdn/expire-1-M/KaTeX/0.10.2/katex.min.css" rel="stylesheet"><script type="text/javascript" id="maid-script" src="https://unpkg.com/mermaid@9.0.1/dist/mermaid.min.js?v=undefined"></script><script>if (window.mermaid) {
  var options = JSON.parse(document.getElementById('maid-script').getAttribute('mermaidoptioins'));
  mermaid.initialize(options);
}</script><meta name="generator" content="Hexo 6.1.0"><link rel="alternate" href="/atom.xml" title="保持好奇心" type="application/atom+xml">
</head><body><div class="wrap" id="barba-wrapper"><header><h1 class="branding"><a href="/" title="保持好奇心"><img class="logo-image" src="/logo.png" alt="logo"></a></h1><ul class="nav nav-list"><li class="nav-list-item"><a class="nav-list-link no-barba" href="/" target="_self">HOME</a></li><li class="nav-list-item"><a class="nav-list-link no-barba" href="/about" target="_self">ABOUT</a></li><li class="nav-list-item"><a class="nav-list-link no-barba" href="/archives" target="_self">ARCHIVES</a></li><li class="nav-list-item"><a class="nav-list-link no-barba" href="https://github.com/roryye" target="_blank">GITHUB</a></li><li class="nav-list-item"><a class="nav-list-link no-barba" href="/atom.xml" target="_self">RSS</a></li></ul></header><div class="barba-container"><main class="container"><div class="post"><article class="post-block"><h1 class="post-title">golang 函数传递 slice 常见的坑</h1><div class="post-info"><a></a>2021-10-29</div><div class="post-content"><p>golang 中的 slice 是动态数组，可方便地进行扩容和传递，正因如此，实际使用时容易出错。为了加深对 slice 的理解和认识，下面一起来看看例题。<br />
例题 1：思考下面的输出结果？</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	s := []<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>&#125;</span><br><span class="line">	editSlice(s, <span class="number">0</span>, <span class="number">3</span>)</span><br><span class="line">	fmt.Println(s)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">editSlice</span><span class="params">(s []<span class="type">int</span>, index, value <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">	s[index] = value</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出：[3 2]</p>
<p>例题 2：思考下面的输出结果？</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	s := []<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>&#125;</span><br><span class="line">	sliceAppend(s, <span class="number">3</span>)</span><br><span class="line">	fmt.Println(s)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sliceAppend</span><span class="params">(s []<span class="type">int</span>, value <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">	s = <span class="built_in">append</span>(s, value)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>输出：[1 2]</p>
<p>下面是 slice 的源码（src/runtime/slice.go）</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> slice <span class="keyword">struct</span> &#123;</span><br><span class="line">	array unsafe.Pointer <span class="comment">// 指向底层数组</span></span><br><span class="line">	<span class="built_in">len</span>   <span class="type">int</span> <span class="comment">// 切片长度</span></span><br><span class="line">	<span class="built_in">cap</span>   <span class="type">int</span> <span class="comment">// 底层数组容量</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 go 中，函数传递的参数都是值传递，传递 slice 的时候是<strong>传递指向 slice 底层数组的指针</strong>，且函数里面对底层数组 slice[0] 的值进行了更改，所以上面的例题 1 输出 [3, 2]。<br />
那为什么例题 2 不是输出 [1 2 3] 呢？这就要涉及到 slice 的扩容了，下面是 slice 扩容的源代码（省略部分代码）：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">growslice</span><span class="params">(et *_type, old slice, <span class="built_in">cap</span> <span class="type">int</span>)</span></span> slice &#123;</span><br><span class="line">	...</span><br><span class="line">	newcap := old.<span class="built_in">cap</span></span><br><span class="line">	doublecap := newcap + newcap</span><br><span class="line"></span><br><span class="line">	... </span><br><span class="line">	memmove(p, old.array, lenmem)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> slice&#123;p, old.<span class="built_in">len</span>, newcap&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以得知当进行 append 操作且容量不够时，就会对 slice 进行扩容，扩容只改变了 cap 的大小。传递进来的 slice 在里面进行了扩容，扩容后新地址的 slice 只是 sliceAppend 函数的局部变量，并未影响外面 slice 的值。<br />
下面的代码可验证：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	s := []<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>&#125;</span><br><span class="line">	fmt.Println(<span class="built_in">len</span>(s), <span class="built_in">cap</span>(s))</span><br><span class="line">	fmt.Println(&amp;s[<span class="number">0</span>])</span><br><span class="line">	sliceAppend(s, <span class="number">3</span>)</span><br><span class="line">	fmt.Println(s)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sliceAppend</span><span class="params">(s []<span class="type">int</span>, value <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">	fmt.Println(<span class="built_in">len</span>(s), <span class="built_in">cap</span>(s))</span><br><span class="line">	fmt.Println(&amp;s[<span class="number">0</span>])</span><br><span class="line">	s = <span class="built_in">append</span>(s, value)</span><br><span class="line">	fmt.Println(<span class="built_in">len</span>(s), <span class="built_in">cap</span>(s))</span><br><span class="line">	fmt.Println(&amp;s[<span class="number">0</span>])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">2 2</span><br><span class="line">0xc0000b2010</span><br><span class="line">2 2</span><br><span class="line">0xc0000b2010</span><br><span class="line">3 4</span><br><span class="line">0xc0000b6000</span><br><span class="line">[1 2]</span><br></pre></td></tr></table></figure>
<p>可以看到扩容后 slice 的地址发生了改变，所以例题 2 输出 [1, 2]。</p>
<p><strong>总结：<br />
请勿传递 slice 到函数且进行 append 操作。<br />
slice 最好在初始化就确定大小，减少内存消耗。</strong></p>
</div></article></div></main><footer><div class="paginator"><a class="prev" href="/oauth-login/">prev</a></div><div class="copyright"><p>保持好奇心 &copy; 2022 <a href="https://beian.miit.gov.cnt" rel="noreferrer" target="_blank">京ICP备2022015182号-1</a></p></div></footer></div></div><script>var _gaq = _gaq || [];
_gaq.push(['_setAccount', 'UA-XXXXXXXX-X']);
_gaq.push(['_trackPageview']);

(function () {
    var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
    ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
})();</script><script src="https://cdnjs.cloudflare.com/ajax/libs/barba.js/1.0.0/barba.min.js"></script><script>document.addEventListener('DOMContentLoaded', function() {
    Barba.Pjax.start()
})</script></body></html>