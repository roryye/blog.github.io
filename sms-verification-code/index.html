<!DOCTYPE html><html lang="zh"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1"><meta name="robots" content="index, follow"><title>验证码发送设计与实现 • 保持好奇心</title><meta name="description" content="验证码发送设计与实现 - roryye"><link rel="icon" href="/favicon.svg"><link rel="stylesheet" href="https://unpkg.com/nanoreset@3.0.1/nanoreset.min.css"><link rel="stylesheet" href="/css/theme.css"><link rel="search" type="application/opensearchdescription+xml" href="/atom.xml" title="保持好奇心"><link href="https://lf9-cdn-tos.bytecdntp.com/cdn/expire-1-M/KaTeX/0.10.2/katex.min.css" rel="stylesheet"><script type="text/javascript" id="maid-script" src="https://unpkg.com/mermaid@9.0.1/dist/mermaid.min.js?v=undefined"></script><script>if (window.mermaid) {
  var options = JSON.parse(document.getElementById('maid-script').getAttribute('mermaidoptioins'));
  mermaid.initialize(options);
}</script><meta name="generator" content="Hexo 6.1.0"><link rel="alternate" href="/atom.xml" title="保持好奇心" type="application/atom+xml">
</head><body><div class="wrap" id="barba-wrapper"><header><h1 class="branding"><a href="/" title="保持好奇心"><img class="logo-image" src="/logo.png" alt="logo"></a></h1><ul class="nav nav-list"><li class="nav-list-item"><a class="nav-list-link no-barba" href="/" target="_self">HOME</a></li><li class="nav-list-item"><a class="nav-list-link no-barba" href="/about" target="_self">ABOUT</a></li><li class="nav-list-item"><a class="nav-list-link no-barba" href="/archives" target="_self">ARCHIVES</a></li><li class="nav-list-item"><a class="nav-list-link no-barba" href="https://github.com/roryye" target="_blank">GITHUB</a></li><li class="nav-list-item"><a class="nav-list-link no-barba" href="/atom.xml" target="_self">RSS</a></li></ul></header><div class="barba-container"><main class="container"><div class="post"><article class="post-block"><h1 class="post-title">验证码发送设计与实现</h1><div class="post-info"><a></a>2022-04-24</div><div class="post-content"><p>验证码发送是一个很常见的场景，比如账号密码的找回，验证码登录等，但是如果稍加不注意，验证码发送接口有可能会造成盗刷，给用户带来不好的体验，且会给企业带来短信成本。接下来我将讨论如何设计验证码发送系统。</p>
<p>验证码发送可以是短信，也可以是邮箱，还可能涉及多个场景（登陆、交易等）。因为手机短信验证码发送及验证接口是无登陆态，任何人都可以触发，所以可能会带来以下的问题：<br />
1、利用短信发送接口造成短信“轰炸”。<br />
2、利用短信校验接口对服务器造成压力。</p>
<p>为了解决上述问题，我们需要记录一个号码的发送次数、发送频率以及校验次数，可以设计一张表来存储这些参数，比如验证码有效时间、每个用户的最大发送次数以及最大校验次数等，方便我们后面来做频控。</p>
<p>验证码配置表</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `verification_setting_info`</span><br><span class="line">(</span><br><span class="line">    `id`                 <span class="type">bigint</span>(<span class="number">20</span>) unsigned <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT,</span><br><span class="line">    `created_at`         datetime(<span class="number">3</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">    `updated_at`         datetime(<span class="number">3</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">    `deleted_at`         datetime(<span class="number">3</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">    `aid`                <span class="type">varchar</span>(<span class="number">64</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;应用 ID&#x27;</span>,</span><br><span class="line">    `expire_time`        <span class="type">int</span> unsigned <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;验证码有效期（秒）&#x27;</span>,</span><br><span class="line">    `apply_interval`     <span class="type">int</span> unsigned <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;验证码下发间隔（秒）&#x27;</span>,</span><br><span class="line">    `max_count_per_day`  <span class="type">int</span> unsigned <span class="keyword">DEFAULT</span> <span class="number">100</span> COMMENT <span class="string">&#x27;每个自然日每个账号的最大下发量&#x27;</span>,</span><br><span class="line">    `code_width`         <span class="type">int</span> unsigned <span class="keyword">DEFAULT</span> <span class="number">6</span> COMMENT <span class="string">&#x27;验证码宽度&#x27;</span>,</span><br><span class="line">    `code_type`          <span class="type">int</span> unsigned <span class="keyword">DEFAULT</span> <span class="number">0</span> COMMENT <span class="string">&#x27;验证码类型：0-纯数字 1-纯字母 2-数字和字母结合&#x27;</span>,</span><br><span class="line">    `content`            <span class="type">varchar</span>(<span class="number">60</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;文案，不得超过 70 字（短信要求）&#x27;</span>,</span><br><span class="line">    `max_validate_times_per_day` <span class="type">int</span> unsigned <span class="keyword">DEFAULT</span> <span class="number">5</span> COMMENT <span class="string">&#x27;每个自然日的最大校验次数&#x27;</span>,</span><br><span class="line">    `type`               <span class="type">int</span> unsigned <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;类型：0-短信，1-邮件&#x27;</span>,</span><br><span class="line">    <span class="keyword">PRIMARY</span> KEY (`id`),</span><br><span class="line">    KEY                  `idx_aid_id`(`aid`)</span><br><span class="line">) ENGINE <span class="operator">=</span> InnoDB AUTO_INCREMENT <span class="operator">=</span> <span class="number">1</span> <span class="keyword">DEFAULT</span> CHARSET <span class="operator">=</span> utf8mb4 COMMENT <span class="operator">=</span> <span class="string">&#x27;验证码配置表&#x27;</span>;</span><br></pre></td></tr></table></figure>
<p>验证码记录表</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `verification_record`</span><br><span class="line">(</span><br><span class="line">    `id`                  <span class="type">bigint</span>(<span class="number">20</span>) unsigned <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT,</span><br><span class="line">    `created_at`          datetime(<span class="number">3</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;验证码生成时间&#x27;</span>,</span><br><span class="line">    `updated_at`          datetime(<span class="number">3</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;更新时间&#x27;</span>,</span><br><span class="line">    `deleted_at`          datetime(<span class="number">3</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">    `msg_id`              <span class="type">varchar</span>(<span class="number">64</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;消息 id，发送验证码返回时获得&#x27;</span>,</span><br><span class="line">    `aid`                 <span class="type">varchar</span>(<span class="number">64</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;应用 ID&#x27;</span>,</span><br><span class="line">    `<span class="keyword">from</span>`                <span class="type">varchar</span>(<span class="number">64</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;发送者&#x27;</span>,</span><br><span class="line">    `receiver`            <span class="type">varchar</span>(<span class="number">64</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;接收者，手机号码或邮箱&#x27;</span>,</span><br><span class="line">    `code`                <span class="type">varchar</span>(<span class="number">64</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;生成的验证码&#x27;</span>,</span><br><span class="line">    `apply_count_per_day` <span class="type">int</span> unsigned <span class="keyword">DEFAULT</span> <span class="number">1</span> COMMENT <span class="string">&#x27;每个自然日的申请次数&#x27;</span>,</span><br><span class="line">    `validate_times_per_day`      <span class="type">int</span> unsigned COMMENT <span class="string">&#x27;每个自然日的校验次数&#x27;</span>,</span><br><span class="line">    <span class="keyword">PRIMARY</span> KEY (`id`),</span><br><span class="line">    KEY                   `idx_aid_from_receiver_id` (`aid`, `<span class="keyword">from</span>`, `receiver`)</span><br><span class="line">) ENGINE <span class="operator">=</span> InnoDB AUTO_INCREMENT <span class="operator">=</span> <span class="number">1</span> <span class="keyword">DEFAULT</span> CHARSET <span class="operator">=</span> utf8mb4 COMMENT <span class="operator">=</span> <span class="string">&#x27;验证码记录表&#x27;</span>;</span><br></pre></td></tr></table></figure>
<p>下面是验证码下发流程图：<br />
<img src="../images/sms-verification-code/sms_send.png" width="50%" height="70%"/></p>
<p>下面是验证码校验流程图：<br />
<img src="../images/sms-verification-code/sms_verify.png" width="50%" height="70%"/></p>
<p>为了更直观表现，下面是验证码下发的时序图：</p>
<pre class="mermaid">sequenceDiagram
	autonumber
  用户 ->>+ 后台服务: 请求获取验证码
	rect rgb(191,223,255)
	note right of 后台服务: 频控：<br>1、发送时间间隔<br>2、当日发送次数
    后台服务 ->>+ 存储: 查询记录
	存储 -->>- 后台服务: 返回结果
	后台服务 ->> 后台服务: 检查是否符合发送要求
	end
	
	后台服务 ->> 后台服务: 1、生成验证码<br>2、生成 msg_id
	
  后台服务 ->>+ 短信供应商: 请求发送验证码
  短信供应商 -->>- 后台服务: 返回请求结果

	后台服务 ->>+ 存储: 更新验证码
	存储 -->>- 后台服务: 返回结果 

	后台服务 -->>- 用户: 返回请求结果</pre>
<p>考虑这样一个场景：同一个账户并发请求下发验证码接口，假如第一次请求发现 apply_count_per_day=19，apply_count_per_day(19)&lt;max_count_per_day(20)判断通过有资格申请验证码，但是此时还没来得及更新 apply_count_per_day=apply_count_per_day+1（上图第4～8步骤之间）。第二个请求查询到脏数据 apply_count_per_day=19，同样有资格申请验证码。<font color="red">这样就绕过了每个自然日每个用户最大下发量的限制。</font><br />
解决方案：将发送验证码放到更新验证码到 DB 步骤之后（即上图第 6 步在第 8 步骤之后），只有下面这条 SQL 执行成功才会请求发送验证码。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">update</span> verification_record</span><br><span class="line"><span class="keyword">set</span> apply_count_per_day<span class="operator">=</span>apply_count_per_day<span class="operator">+</span><span class="number">1</span></span><br><span class="line"><span class="keyword">where</span> apply_count_per_day<span class="operator">&lt;</span>max_checkout_count;</span><br></pre></td></tr></table></figure>
<p>下面是验证码校验的时序图：</p>
<pre class="mermaid">sequenceDiagram
	autonumber
  用户 ->>+ 后台服务: 请求校验

  后台服务 ->> 后台服务: 校验验证码

	rect rgb(191,223,255)
		note right of 后台服务: 频控：<br>1、是否有验证码<br>2、验证码是否过期<br>3、校验次数
		后台服务 ->>+ 存储: 查询记录
		存储 -->- 后台服务: 返回结果
		后台服务 ->> 后台服务: 检查是否符合发送要求
	end

	后台服务 -->> 后台服务: 校验结果
	后台服务 ->>+ 存储: 更新 validate_times_per_day
	存储 -->>- 后台服务: 返回
	
  后台服务 -->>- 用户: 返回校验结果</pre>
<p>考虑这样一个场景：当校验验证码的时候，同一个用户并发请求。假如第一个请求查询到 validate_times_per_day=9，validate_times_per_day(9)&lt;max_validate_times_per_day(10)，判断通过可以校验验证码，但是此时还没来得及更新 validate_times_per_day=validate_times_per_day+1，第二个请求查询读到脏数据 validate_times_per_day=9，同样可以通过判断继续校验。<font color="red">这样就绕过了最大检验次数的限制，别人可以利用这个漏洞大量并发穷举验证码来增加暴力破解的概率。</font><br />
解决方案：把验证码校验放在更新 DB 之后（即上图的第 6 步放到第 8 步之后），只有下面这条 SQL 执行成功才会校验验证码。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">update</span> verification_record</span><br><span class="line"><span class="keyword">set</span> validate_times_per_day<span class="operator">=</span>validate_times_per_day<span class="operator">+</span><span class="number">1</span></span><br><span class="line"><span class="keyword">where</span> validate_times_per_day<span class="operator">&lt;</span>max_validate_times_per_day;</span><br></pre></td></tr></table></figure>
<p><strong>注意：判断发送时间间隔时需要比配置的 apply_interval 要小。</strong><br />
比如下面的判断代码段：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="type">int64</span>(time.Now().Sub(record.UpdatedAt).Seconds()) &lt; <span class="type">int64</span>(apply_interval) &#123;</span><br><span class="line">	<span class="keyword">return</span> errs.Newf(errcode.VER_CODE_INTERVAL_SHORT, <span class="string">&quot;the sending interval is too short&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的判断逻辑是有小问题的，假如 apply_interval=60s，前端也进行发送时间限制，用户点击发送验证码，前端页面展示 60s 倒计时，传递到后端落到数据库时 <font color="red">verification_record.update_at 参数是偏大的</font>。如果下一次前端解除发送限制，用户立刻又点击发送验证码，后端判断这里可能会返回失败，因为此刻的时间 - record.UpdatedAt（偏大）&lt; 60s。为了更好的用户体验，所以在判断时可以将 apply_interval 设置得偏小一些（视网络情况酌情而定）。<br />
修改后（减了 5s）：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="type">int64</span>(time.Now().Sub(record.UpdatedAt).Seconds()) &lt; <span class="type">int64</span>(apply_interval<span class="number">-5</span>) &#123;</span><br><span class="line">	<span class="keyword">return</span> errs.Newf(errcode.VER_CODE_INTERVAL_SHORT, <span class="string">&quot;the sending interval is too short&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></article></div></main><footer><div class="paginator"><a class="prev" href="/hello-world/">prev</a></div><div class="copyright"><p>保持好奇心 &copy; 2022 <a href="https://beian.miit.gov.cnt" rel="noreferrer" target="_blank">京ICP备2022015182号-1</a></p></div></footer></div></div><script>var _gaq = _gaq || [];
_gaq.push(['_setAccount', 'UA-XXXXXXXX-X']);
_gaq.push(['_trackPageview']);

(function () {
    var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
    ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
})();</script><script src="https://cdnjs.cloudflare.com/ajax/libs/barba.js/1.0.0/barba.min.js"></script><script>document.addEventListener('DOMContentLoaded', function() {
    Barba.Pjax.start()
})</script></body></html>